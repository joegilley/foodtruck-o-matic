"""
This module defines the various configuration layouts as Python class objects.  By extending the base class' default values, multiple definitions depending on the environment are created.
"""

import os
import logging.config
import yaml
from os import environ as env
from datetime import timedelta

class Config:
  """
  The base configuration class.  It *can* stand on its own, as a very minimal set up.
  """
  DEBUG = False
  """Flask standard setting"""
  TESTING = False
  """Flask standard setting"""
  SQLALCHEMY_DATABASE_URI = 'postgresql://localhost/foodtruck'
  """Flask-SQLAlchemy standard setting

  This is the database URI that the app will be configured with.  DB foodtruck must exist.
  """
  API_ENDPOINT = 'api'
  """This specifies where the api Blueprint will be mounted.

  This configuration affords a great deal of flexibility, primarily for the production server.  This will let us mount multiple apis to the same domain, but maintian logical code separation.  Additionally, one could version the API being mounted, to preserve deprecated APIs for backwards compatibility.
  """

class ProductionConfig(Config):
  """
  This is the configuration that will be used in the production environment
  """
  DEBUG = False
  """No debug mode, that would be unsafe!"""
  SQLALCHEMY_DATABASE_URI = env['DATABASE_URL']
  """Let the production server's environment take care of this setting.  Better to not expose some things."""
  SERVER_NAME = 'josephgilley.com'
  """Used for the generation of URLs by ``url_for``, though it currently isn't being used."""
  API_ENDPOINT = 'v1'
  """Overwrite the endpoing on the production server to represent the version of the api.  The application will be mounted on the sub-domain 'api.' using a production quality HTTP server."""

class DevelopmentConfig(Config):
  """
  This is the configuration one would use on their local machine for development.  It provides the most generous of runtimes, allowing in-browser debugging, and logging Flask-SQLAlchemy SQL queries (useful for gauging a request's impact)
  """
  DEVELOPMENT = True
  DEBUG = True
  SQLALCHEMY_ECHO = True
  """Print out the SQL statements generated by the models and queries"""

class TestingConfig(Config):
  """
  This is the configuration used by the test environment.  Technically, it should use a separate database, populated with more corner-case reaching test data.  However, the early stages of this application does not mutate any existing data, so we can get away with testing on our development database for now.
  """
  TESTING = True
  SQLALCHEMY_DATABASE_URI = 'postgresql://localhost/foodtruck'
  """This should not be the same as the development server, and **definitely** not the production database server.  But we're being sneaky for now"""

def setup_log(config_path='logging.yaml'):
  """Taking the path of a logging configuration file, this function will set up the Python logging utility as prescribed

  This method supports the configuration file being ``json`` or ``yaml``.  For lack of a separate designated logging module, this function will belong in this module for now.  Also, it would be better for the configuration classes to own the path of which configuration file (Testing, Development, Prod, etc.) to use for set up.

  Args:
    config_path (str, optional): The path to the logging file, relative to the config file, not the calling file.  The file extension determines whether the file will be ``json`` or ``yaml``.

  """
  if os.path.exists(config_path):
    with open(config_path, 'rt') as f:
      if config_path.endswith('yaml'):
        logging.config.dictConfig(yaml.load(f))
      elif config_path.endswith('json'):
        logging.config.dictConfig(json.load(f))
      log = logging.getLogger(__name__)
      log.debug('Logger setup from configuration file: {}'.format(config_path))
  else:
    print 'Error retrieving logging file!'
